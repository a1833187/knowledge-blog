# JVM

### JVM内存区域划分

内存划分的原因:方便管理和调用.

1. 程序计数器:**内存中最小的区域**,保存了下一条要执行的指令的地址.由于操作系统是以线程为单位调度执行的,所以每个线程都有1个程序计数器

2. 栈:保存局部变量和方法调用信息.每个线程都有1个栈

3. 堆:一个进程有1个堆,一个进程中的多个线程共享1个堆.是**内存中空间最大的区域**.new出来的对象是存在堆中.成员变量和new出来的对象存放在堆中,不区分内置类型还是引用类型

   ```java
   public void func(){
       String s (存放在栈上) = new String() (存放在堆上)
   }
   ```

4. 方法区:存放的是"类对象",

### JVM类加载机制

类加载作用:将.class文件加载到内存中,构建成类对象

Loading

先找到对应的.class文件,打开并读取.class文件,同时初步生成一个类对象.

Linking

1. Verification:验证读到的内容是否和规范中规定的格式完全匹配.如果验证失败,则会类加载失败,并抛出异常

2. Preparation:给静态变量分配内存,然后分配初始值

3. Resolution:将常量池内的符号引用替换为直接引用的过程,也就是初始化常量.

   .class文件中,常量是集中放置的,每个常量有一个编号.

   .class文件中,结构体里在缺省情况下只是记录了编号,因此需要根据编号将对应的内容填充到类对象中

Initializing

真正对类对象进行初始化,尤其是对静态成员初始化

常见的面试题

1. 静态代码块,构造代码块,构造方法的执行顺序

   > 由于函数的调用是在栈中进行的.所以
   >
   > 1. 父类先执行,子类后执行
   > 2. 构造代码块优先于构造方法执行
   > 3. 静态代码块优先于其他两者执行且只在类加载的时候执行一次

2. "双亲委派模型"

   > 描述的是JVM中的类加载器,如何根据类的全限定名找到.class文件的过程
   >
   > JVM提供了多个类加载器,每个类加载器负责一个片区
   >
   > 默认的类加载器有3个
   >
   > 1. BootSrapClassLoader:负责加载标准库中的类
   > 2. ExtensionClassLoader:负责加载jdk拓展中的类
   > 3. ApplicationClassLoader:负责加载当前项目目录中的类
   > 4. 还可以自定义类加载器
   >
   > 双亲委派模型就是通过这些类加载器去一层一层寻找整个目录中的.class文件.
   >
   > 过程:
   >
   > 1. ApplicationClassLoader先判断其父类是否加载过,如果加载过就加载ApplicationClassLoader中管控的类
   > 2. ExtensionClassLoader先判断其父类是否加载过,如果加载过就加载ExtensionClassLoader中管控的类
   > 3. BootSrapClassLoader由于没有父类,则直接在自己管控中的类中查找带查找的.class文件
   >
   > 类似于递归的方式由父到子的查找.JVM之所以采用这种"递归"的方式查找,是为了保证查找到的.class文件唯一(**即使自定义的类与标准库中的类名重复也会正常加载标准库中的类而不加载自己定义的类**)

### JVM的垃圾回收(gc)

申请内存的时机一般都是明确的,而释放内存的时机则不是那么清楚.

按照JVM内存区域划分,其中程序计数器只占用1个地址,不涉及内存释放;而栈中的变量随函数调用结束自动释放内存,而方法区中存储的类对象是在"类卸载"时释放内存.而**最需要gc释放的内存是堆中申请的内存**

堆

1. 正在使用中的内存:不释放
2. 不再使用,但尚未回收的内存:不释放,等到完全不使用后再回收
3. 未分配的内存:直接回收

垃圾回收的基本单位是"对象",不是"字节"



垃圾回收的过程

1. 判定垃圾

   1. 基于引用计数(非java采取的方案)

      针对每个对象,都会额外引入一小段内存负责存储指向该对象的引用的个数.

      当引用个数为0时释放内存.

      缺陷:

      1. 空间利用率比较低.
      2. 会有"循环引用"的问题

   2. 基于可达性分析(java采取的方案)

      通过额外的线程,定期的针对整个内存空间的对象进行扫描.有一些起始位置(GCRoots)(栈上的局部变量,方法区的静态成员指向的对象,常量池中引用的对象),通过类似于深度优先便利的方式将能够访问到的对象作上标记,不能访问到的就没有标记,即是垃圾

      解决了基于引用计数回收垃圾的两个缺点,但又引入了新的缺点:系统开销大.

   两种思路的本质都是当指向该对象的引用次数为0时回收该对象占用的内存

2. 释放垃圾

   1. 标记 - 清除

      标记:就是可达性分析的过程

      清除:直接将垃圾对象占用的内存回收掉.这种处理方式会造成"内存离散"的问题.由这种方式回收的内存在再次申请时无法一次性申请比较大的内存.

   2. 复制算法

      在为对象申请内存时,开辟实际使用内存的2倍内存空间.在对象需要回收时,将遗留下来的内存复制到另一半没有使用的内存中,然后将使用过的这一整块内存都回收掉.缺点是空间利用率低,每次申请内存都要申请2倍的内存

   3. 标记 - 整理

      整理:类似于在数组中删除中间元素的结果.将离散的待回收的内存搬运到开辟内存的末尾,将仍需使用的内存片段移到开辟内存的前半部分,然后回收掉开辟内存的后半部分.缺点是每次回收时消耗的时间长.

   4. 分代回收: 实际上gc是将上述三种机制结合起来使用的.按照对象的"年龄"(每当对象熬过一次gc扫描即为长了一岁)进行分类:伊甸区,幸存区,老年区.伊甸区中存放的是比较新的对象,由于大部分对象的"寿命"都比较短,所以gc对伊甸区的对象的扫描频率比较高,且用的是复制算法;熬过1轮gc扫描的对象进入到幸存区(幸存区是两块大小相同的比较小的内存区域),在内存区采用的也是复制算法回收内存;在幸存区熬过多次gc扫描的对象进入到老年区,根据实际经验证明进入老年区的对象的"命格"都比较硬.所以gc针对老年区的对象的扫描频率比较低,且用的是标记-整理的算法.

      对于占用内存比较多的对象直接进入老年区,因为对这类内存进行复制算法开销过大,不适合使用复制算法.

垃圾回收器

1. Serial收集器

2. Serial Old收集器

   上述的垃圾回收器都是串行收集,在进行垃圾的扫描和释放的时候,业务线程要停止工作.这种方式扫描和释放的慢,也会产生严重的STW(Stop The World)

3. ParNew收集器

4. Paralell Old收集器

   上述的垃圾回收器都是并发收集,引入多线程

5. CMS收集器:设计初衷是尽可能的让STW的时间短

   1. 初始标记:速度很快,会引起短暂的STW(找到GCRoots)
   2. 并发标记:速度较慢,但是可以和业务线程并发执行,不会产生STW
   3. 重新标记:针对2的结果进行微调,虽然会产生STW,但是只是微调,速度快
   4. 回收内存:可以和业务线程并发

6. G1收集器(唯一一款全区域的垃圾回收器):把整个内存分成了很多小的区域region,给这些region进行了不同的标记(新生代,老年代),再扫描的时候,一次扫若干个region(尽管一轮GC不能完全扫描完,分多次来扫描),对于业务线程的影响是比较小的.    G1收集器可以将STW停顿时间优化到1ms

   上述的垃圾回收器的核心思路都是化整为零

