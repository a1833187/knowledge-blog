## dp总结

1. dp的各种类型,用的条件,用法以及心得

   1. 记忆化搜索:

      1. 定义:自上至下的一种递归优化.通过记录递归过程中重复出现的一些子结果来减少重复计算.

      2. 适用条件:路径的搜索上,某些博弈论问题上, 更宽泛的说是用在具有多个重复的中间结果的递归上,

         既然是一种递归的优化,那么更多的是用在dfs的情景中.事实上,刷题刷到现在能够只用dfs去解决问题的题目已经很少见了.毕竟dfs的适用数据规模是30左右.顾名思义,"记忆化搜索",所以更多的是用在路径的搜索上.还见过的是用在博弈论上,因为博弈论就是两个人之间不断的递归看谁最后能赢.且存在很多中间重复的过程.

      3. 用法:首先需要定义一个cache数组用来存储中间结果.然后大致过程和dfs相当.dfs的三部曲:

         1. 设计好递归参数的(入参:dfs的入口参数)和(出参:dfs的出口参数)

         2. 设置好递归函数的出口(Base Case)

         3. 编写(最小单元)的处理逻辑:一般就是按照某个顺序遍历当前所有情况的每个情况是如何递归到下一步的.

            其中最难的是如何找Base Case.因为递归函数的出口可能不止一个,大致可以分为有效情况和无效情况两种(尽可能的把可以一下子得出结果的条件全部写上).**记忆化搜索在也就是在dfs中找Base上以及编写最小单元的处理逻辑后及时更新中间结果.**

      4. 记忆化搜索说难也不难,只要你把cache数组设定好,按照dfs的思路来即可.

   2. 背包dp

      1. 定义:给定了"物品"的"成本"和"价值",在有限的成本的情况下尽可能多的获取到更多的利润.

      2. 适用条件:能够抽象成背包的问题的条件:泛指**一类给定价值与成本**,同时**限制决策规则**,在这样的条件下**如何实现价值最大化**的问题.能够转化成背包问题的问题其实还是比较好看出来的,因为背包dp不管是定义还是各种类型已经各种类型的解题方式都是比较固定的.

      3. 各种背包问题的类型以及解题思路

         > 01背包:给定了物品的价值与成本且规定每个物品只有1件,在给定成本的情况下如何选择物品使得物品的价值和最大.
         >
         > 01背包二维解:f[i]\[C]:体积不超过C,前i个物品的价值的最大值
         >
         > f[i]\[C] = max(f[i-1]\[C],f[i-1]\[C-v[i]]+A[i])
         >
         > 根据二维状态转移方程可以看出:第i行的某个值的计算只依赖于对应上一行的位置以及上一行左边的某个具体位置.因此用一维遍历时要从右到左遍历
         >
         > 01背包一维解:f[C]:体积不超过C的物品的价值最大值
         >
         > ```java
         > for(int i = 0; i < n; i++){
         > 	for(int j = C; j > 0; j--){
         >         //从右到左遍历的原因:当第一行中的物品遍历完后(也就是第一个物品的最大值后),我们在遍历前两个物品时用到的状态是前一个物品的状态,此时如果从左到右遍历,就会把前一个物品的状态提前更新成前两个物品的状态,这时候在获取前两个物品的后续状态(C比较大的时候)依据的前面的状态就有可能不再是前一个物品的状态了.	
         >         if(j-v[i]>=0){
         > 			f[j] = Math.max(f[j],f[j-v[i]]+A[i]);
         >         }
         >     }
         > }
         > ```
         >
         > 01背包恰好装满的情况下的最大价值
         >
         > f[i]\[C]:前i件物品体积恰好为C时的最大价值.因此f[i]\[C]依赖的是f[i-1]\[C]和f[i-1]\[C-v[i]]+A[i]中的有效值,即该情况下是满足恰好装满的条件的.
         >
         > 二维解:与01背包一样,只不过初始f[i]\[0]为0,其余值为-INF或者INF(取决于题目中要求的是最大值or最小值).
         >
         > 一维解:与01背包一样,只不过初始f[0]为0,其余值为-INF或者INF.在遍历的时候要判断一下前一个状态是否是-INF,如果是则不遍历.当然对于大部分题目而言,就算遍历也没关系,遍历完最后再判断也可以.
         >
         > 完全背包:给定了物品的价值和数目且每个物品有无限件,在给定容量的情况下如如何使选取的物品的总价值最大
         >
         > 二维解:f[i]\[j]:前i个物品中体积不超过j的最大价值
         >
         > f[i]\[j] = max(f[i-1]\[j],f[i]\[j-v[i]]+A[i])
         >
         > 一维解:f[j] = max(f[j],f[j-v[i]]+A[i])
         >
         > ```java
         > for(int i = 0; i < n; i++){
         >     for(int j = 0; j < C; j++){
         >         /*从左到右遍历的原因:完全背包规定每个物品可以取很多从,
         >         因此f[i][j] = max(f[i-1][j](不选第i件物品),f[i-1][j-v[i]]+A[i](选1件i物品),
         >         f[i-1][j-2v[i]]+2A[i]....)
         >         f[i][j-v[i]] = max(f[i-1][j-v[i]]),f[i-1][j-2v[i]]+A[i]...)
         >         所以f[i][j] = max(f[i-1][j],f[i][j-v[i]]+A[i])
         >         所以f[j]的状态由当前i件物品中的前一个状态决定而不是前i-1件物品中的前一个状态,所以需要先更新前面的状态.至于f[j],其既可以代表前i-1件物品的状态也可以代表前i件物品的状态,主要就是看你是否选取f[j]		*/
         >         if(j-v[i] >= 0){
         >             f[j] = Math.max(f[j],f[j-v[i]]+A[i]);
         >         }
         >     }
         > }
         > ```
         >
         > 完全背包恰好装满问题:与01背包恰好装满一样,只是遍历顺序变成从左到右.
         >
         > dp的遍历顺序是根据状态转移方程中的依赖关系确定的,比如f[i]\[j] 依赖f[i-1]\[j],那么i-1就需要先于i计算,所以i就是从小到大遍历,如果f[i]\[j]依赖于f[i+1]\[j-1]那么意味着i从小到大遍历,j从大到小遍历.至于是先遍历i还是先遍历j,则需要看依赖关系中需要先求哪个值.比如01背包f[i]\[j] = max(f[i-1]\[j],f[i-1]\[j-v[i]]+A[i]),说明在计算f[i]\[j]时,f[i-1]中的j列和j-v[i]列都要被算好,所以是i嵌套j.  **要满足依赖值先于状态值被计算**
         >
         > 多重背包:每种背包有有限个个数.
         >
         > 二维解:f[i]\[j]体积不超过j的情况下前i件物品的最大价值.
         >
         > f[i]\[j] = max(f[i-1]\[j-k*v[i]]+k*A[i])(0<=k<=s[i])
         >
         > 一维解同01背包一样,但是不能像完全背包那样降低时间复杂度,因为每种背包的个数是有限的,不能无限取.
         >
         > ```java
         > for(int i = 0; i < n; i++){
         >     for(int j = C; j >= v[i]; j--){
         >         for(int k = 0; k <= s[i] && j >= k*v[i]; k++){
         > 			f[j] = Math.max(f[j],f[j-k*v[i]]+k*A[i]);
         > 		}
         >     }
         > }
         > ```
         >
         > 多重背包的优化
         >
         > 1. 二进制优化:**本质是将物品的总数量用更小的物品组合表示出来.**相比于普通的扁平化将s[i]拆成1个1个的,二进制优化将s[i]拆成了ceil(log(s[i]))个,比如s[i]  = 10---->1,2,4,3(3=10-7),这样拆分可以不重不漏的把0-10所有情况考虑到
         >
         >    ```java
         >    List<Integer> ww = new ArrayList<>();
         >    List<Integer> AA = new ArrayList<>();
         >    for(int i = 0; i < n; i++){
         >    	int val = s[i];
         >        for(int k = 1; k <= val; k*=2){
         >            val-=k;
         >            ww.add(k*w[i]);
         >            AA.add(k*A[i]);
         >        }
         >        if(val > 0){
         >            ww.add(val*w[i]);
         >            AA.add(val*A[i]);
         >        }
         >    }
         >    //然后按照01背包的遍历形式对ww和AA遍历.
         >    ```
         >
         > 2. 单调队列优化:本质上是对状态进行拆分.考虑去第i件物品时,我们需要考虑具体取多少件第i件物品能达到最优(0-s[i]).即,f[i]\[j] = max(f[i-1]\[j-k\*v[i]] + k\*A[i]),而对于同一个物品的状态转移,其遵循从取当前物品体积余相同的前面的最优状态获得,例如:当期容量为10,物品体积为2,10<----(8,6,4..),9<----(7,5,3...).所以我们可以通过物品的体积w[i]来对f[i]\[j]的状态按余数分成w[i]份,每份都可以通过O(1)直接转移到最优态.而要想做到O(1),我们就需要用一个单调队列去维护一个窗口,使这个队列的头元素是最优值.
         >
         >    ```java
         >    int[] dp = new int[C+1];
         >    int[] g = new int[C+1];
         >    int[] que = new int[C+1];
         >    
         >    for(int i = 0; i < n; i++){
         >        //因为要从小到大遍历,所以需要一个辅助数组去记录上一行的状态.
         >    	g = dp.clone();
         >        //遍历每个余数.
         >        for(int r = 0; r < v[i];r++){
         >    		int head = 0,tail = -1;
         >            //每个余数对应的状态.
         >            for(int k = r; k <= C; k+=v[i]){
         >                //不选取第i个物品
         >                dp[k] = g[k];
         >                //滑动窗口的队头元素需要保证是"可以用"的.比如说s[i] = 3,v[i]=2,当k
         >                //为10时,依赖的最前面的状态就是10-3*2=4,不会用到2和0.
         >    			while(head <= tail && k - que[head] > s[i]*v[i]) head++;
         >                //如果当前值的最优解大于队尾元素,曾对队尾元素进行更新.(保证了队列的单调递减)
         >                //比较的规则:队尾对应空间的最优解+(当前空间-队尾空间)内可以存放的当前物品的价值和 是否大于当前空间的最优解.
         >                while(head <= tail && g[que[tail]]+
         >                      (k-que[tail])/v[i]*A[i]<=g[k]) 				
         >                    	tail--;
         >                que[++tail] = k;
         >                if(head<=tail)
         >                  dp[k] = Math.max(dp[k],g[que[head]]+(k-que[head])/v[i]*A[i]);
         >            }
         >        }
         >    }
         >    ```
         >
         > 混合背包:每件物品的数量从0-s[i]不等,s[i]可以是一个具体的数也可以是INF(无限大).
         >
         > 混合背包就相当于把01背包,完全背包,多重背包混合在一起,在处理的时候,可以把多重背包和01背包放在一起处理(用二进制优化并从后往前遍历),完全背包单独处理(从前往后遍历).
         >
         > 分组背包:在取物品的时候不是以件为单位,而是以组为单位.有多种形式
         >
         > 1. 每组里面最多能取1件:以组为单位的01背包,在考虑选取某个组时,遍历这个组所有情况并取最优
         > 2. 每组里面必须取1件:跟1类似,只是在处理的时候把不取的情况(f[i-1]\[j])去掉即可.
         >
         > 多维背包:"成本"的维度不再是重量这一个维度,而是存在多个维度.处理的时候只是把不同的维度列举出来,实质和其他的背包问题一样.
         >
         > 在多维背包中的多个维度中,每个维度不一定都是不超过.也有可能有些维度是至少.假设维度j是至少,此时对于状态转移方程中的f[i]\[j][k]中的j我们在考虑选取的情况下要考虑到j为负数也符合条件的情况(j为负数说明当前"物品"的j属性已经大于f[i]\[j]\[k]状态下的j了,所以满足条件).这时处理负数状态有两种方式:
         >
         > 1. 根据题目的要求看是否能将f[i]\[负权]\[k]等价到f[i]\[0]\[k]上,能够等价到0上的条件是题目中说明了"物品"的j的属性非0.
         > 2. 将至少为j处理为全部的-不超过j-1的.此时需要考虑的一个问题就是精度问题(可能要用到大数.)
         >
         > 树形背包:在分组背包的基础上使得每组与每组之间的物品产生了依赖关系.即选择子节点的物品时必须选择其父节点的物品.
         >
         > 状态定义:f[u]\[j]:以u为根节点的子树,且重量不超过j的最大价值.
         >
         > f[u]\[j] = Math.max(f[u]\[j],f[u]\[j-k]+f[x]\[k])(k ∈ [0,j-v[u]],x是u的子节点).
         >
         > 对状态转移方程的理解:因为每次选择u为根节点的子树时必须选择根节点u,f[u]\[j-k]就相当于在j空间内的一部分内装下u物品,然后在剩余的空间选择最优的子树f[x]\[k]放进去.遍历求得一个和是的k使得将子树x放入k空间内能使价值最大化.
         >
         > 由状态方程可以得出在计算u之前,需要提前递归得到到u的所有子树x的状态.
         >
         > ```java
         > //w[i]表示重量,v[i]表示价值,p[i]表示该节点的父节点的序号,根节点内的p为-1
         > int N = 110; int M = 110 * 2;
         > int[] edge = new int[M];
         > int[] head = new int[N];
         > int[] next = new int[M];
         > int[] vi,int[] wi;
         > int n,c,idx;
         > int[][] f;
         > //链式向前星存图:能够表示每个边的起点(父节点),终点(子节点)以及父节点的下一个子节点
         > //链式向前星存图的模板基本上是固定的.
         > public void add(int p,int c){
         >     edge[index] = c; //存放的是子节点
         >     next[index] = head[p]; //存放的是父节点的下一个子节点
         >     head[p] = index; //存放的是当前父节点的对应的id编号.
         >     index++;
         > }
         > public void dfs(int u){
         >     int w = wi[u];
         >         int v = vi[u];
         >     //选取u的子树必须选取u节点这个值本身.
         >         for(int i = w; i <= c; i++){
         >             f[u][i] += v;
         >         }
         >     for(int i = head[u]; i != -1; i = next[i]){
         >         //选出u的某个节点
         >         int x = edge[i];
         >         //首先递归得出x的状态值.然后才能算k
         >         dfs(x);
         >         //这里遍历重量必须从大到小.因为是依靠上一层的未更新的值中挑选出一个最大值.
         >         for(int j = c; j >= w; j--){
         >             for(int k = 0; k <= j-w; k++){
         >                 f[u][j] = Math,max(f[u][j],f[u][j-k]+f[x][k]);
         >             }
         >         }
         >     }
         > }
         > public int getMaxValue(int N,int C,int[] w,int[] v,int[] p){
         >     n = N;c = C: vi = v; wi = w;
         >     int root = -1;
         >     Arrays.fill(head,-1);
         >     f = new int[N+1][C+1];
         >     for(int i = 0; i < n; i++){
         >         if(p[i] = -1){
         >             root = i;
         >         }else{
         > 			add(p[i],i);
         >         }
         >     }
         >     dfs(root);
         >     return
         > }
         > ```
         >
         > 常规树形背包的时间复杂度为O(n*c^2)(n为物品个数,c为总重量).有时候当题目中的物品重量c很大而物品个数n比较小且"依赖"的物品个数比较少时,可以枚举每组的所有可挑选的物品分类.变成分组背包来解决(你懂得..你做过.你应该会..)

   3. 序列dp

      1. 定义:在数组和字符串上求某个条件下的最优值的情况,

      2. 适用条件:跟定义类似.对于字符串而言,状态f\[i][j]表示为字符串s的前i个字符和字符串t的前j个字符的最优解.对于数组而言,f[i]表示前i个元素的最优解.(遇见的数组上的序列dp有很多题的状态定义都是f[i]都是以i结尾的前i个值的最优解.)

      3. 常见题:LCS(最长公共子序列),LIS(最长递增子序列)以及二者的转换.

         最长子序列相关的问题:

         1. 两个字符串(数组)中的最长上升子序列:f[i]\[j] = f[i-1]\[j-1]+1 || max(f[i]\[j-1],f[i-1]\[j])

         2. 一个数组中的最长上升子序列

            1. 动态规划(O(n2)):f[i] = max(f[i],f[j]+1),(arr[i]>arr[j])

            2. **贪心加二分查找:其实就是维护一个滑动窗口**,当后面的元素比这个滑动窗口最后一个元素大的时候就添加到滑动窗口的最后,同时更新滑动窗口的长度和最后一个元素;当后面的元素小于等于滑动窗口最后一个元素的时候,在已有的滑动窗口中用二分查找(因为有序)去查找更靠后的第一个比该元素小的元素的位置pos并把滑动窗口中pos+1的位置更新为该元素.这样维护的滑动窗口有两个含义:**1是前面已有的最大的上升子序列的长度,在后面进行更新时如果发现有比前面长度更长的上升子序列则随时更新,如果没有,虽然滑动窗口中某些"应该属于前面元素的值"被更新为后面的元素的值但也不影响len(因为在更新后面的元素的时候,除非后面的上升子序列的长度大于前面的上升子序列的长度,否则len是不更新的.)**

               ```java
               if(f[len-1] < g[i]){
               	f[len++] = g[i];	
               }else{
                   int l = 0, r = len-1;
                   while(l < r){
                       int mid = (l+r)>>1;
                       //二分查找的时候这里要注意=的情况应该给r更新.(因为找的是
                       //相等元素靠左的元素)
                       //进一步解释:当遇到相等元素时,说明mid已经是第一个比该元素小的元素的位置+1的位置
                       //所以此时要更新的是r.
                       if(f[mid] < g[i]){
                           l = mid + 1;
                       }else{
                           r = mid;
                       }
                       f[l] = g[i];
                   }
               }
               ```

            3. 最长子序列转化为最长上升子序列:当题目中强调某个数组(字符串)元素不重复的时候,我们就可以将原来存放数组元素的数组改成存放数组元素对应下标的数组.对于下标而言,其严格遵循单调递增.然后另一个数组存放其对应元素在第一个数组中出现的下标(没有出现就舍弃掉).         当然还存在别的情况下也可以转换,总之能够转换的前提是两个求最长公共子序列的序列中有一个序列可以根据问题背景转化成有序的序列,然后另一个序列中的值可以转换成有序序列中的值.    (比如一个序列是有序的,其实也可以转换成LIS):

               ```
               将有序序列A中的值存入set中,然后更新另一个序列B中的值,使其相对顺序不变且只保留有序序列中有的值.
               然后对序列B进行LIS:注意如果不是要求严格递增(非递减啥的..),可以在维护滑动窗口时把等于的情况考虑到前面:后面的元素大于等于滑动窗口的最后一个元素时,加进来即可.
               ```

            4. 得到对应的子序列的最小操作次数:**就是先求出两个数组(字符串)中的最长子序列,然后再用n-最长子序列的长度**.

   4. 区间dp

      1. 定义:求得的最优解是属于一个区间的最优解
      2. 适用条件:常的一个大区间的状态转移是根据这个区间中某些小区间的最优解的选取或累加得到的.**区间dp有一个很明显的条件就是对某个区间的两个端点有比较强烈的要求.**
      3. 经验:区间dp的遍历顺序与枚举一个区间的左右端点的顺序有关.例如:回文串(先枚举左端点,再枚举右端点).典型的区间dp的问题有:矩阵连乘,回文串,合并石子.  某些区间形式的博弈论也可以用区间dp来做,这时候状态定义的就是先手和后手的比分的最大差值(这个很秀).所以在做博弈论的题目的时候,不一定非要用记忆化搜索,应该首先考虑区间dp能不能做.

   5. 状压dp

      1. 通过状态压缩将题目中的条件转化成一种容易处理的条件.常见的就是把有限个集对应到二进制的低位上.

      2. 最短路径优先考虑dp或者bfs

         利用bfs去寻找最短路径时,最先找到的一定是最短的,不需要另外再加什么判断

         当一个搜索的题中可以走重边但也需要控制节点的访问情况是可以用 isVisited[v]\[mask]来表示,v表示当前节点,mask表示走都当前节点前所经历的情况

   6. 数位dp:一般形式:[a,b]\(a<=b)内符合条件的数值个数为多少.通常需要一个dp(int x)求出[0,x]内的情况.

      数位dp一般是从高位到低位去分情况讨论.

      ```java
      /*
      数位dp的一般过程:
      1.首先需要打个表,这个表中表示了数n的某一位为某个值时的合法值个数(自我感觉数位dp的dp也就是这个表了.....)
      2.然后去求解dp(int x)这个函数:
      	1.首先从高位到低位,每一位按照从高到低或者是二进制中的选0 or 1的顺序选出某一个值,让该位置的值变成选中的一个值,然后统计该位之后的情况,不需要考虑该位之前的情况,因为是从高到低考虑的,所以前面的都考虑过了.统计该位的值以及之后的情况(打表中的某个值)凑成的合法值.然后统计下一位,在统计的过程中,需要根据题目要求去限制位与位之间的关系:通常是当达到某一个位以后发现和前面的已经统计过的位冲突,直接break.如果到最后1位还没有break,那么要记得加上x这个值本身(因为在更改x的每一位的值的时候通常是不会包含x的该位本身的值的)
      	
      数位dp的求dp(int x)还是有模板格式的.  比较难搞的还是dp打表.
      */
      ```

      数位dp用到的思想:dp,打表.排列组合.位运算,状态压缩.

   7. 求最优方案对应的整个过程:

      1. 在遍历的过程中,纪录每一步遍历过程中选择的前一步的节点的值并存储在一个数组g中.在遍历结束后,根据g从后往前遍历得到整个过程.比如说:路径问题的最优路径.
      2. 在遍历结束之后,根据f从后往前遍历,得到每次选取的值.

   8. 求最优方案的个数:大体上还是求最优方案,只不过是在遍历的过程中动态更新当前最优值的个数SIZE,并记录最优解对应的值MAX是多少.然后在遍历结束后遍历f这个数组,看有哪些值等于MAX.然后对应的更新SIZE.

2. 什么问题可以用dp去解决.

   1. 求最大值/最小值
   2. 求方案可不可行
   3. 求方案总数
   4. 技巧:
      1. 拿到一道题首先需要做的是去看这道题的数据规模,数据规模决定了最坏的时间复杂度.
      2. 动态规划在解决最优解方面确实很厉害.但不是所有的题都适合动态规划(即使这道题动态规划能够解决),比如在解决一些求最短路径问题上时bfs就远远优于动态规划.
