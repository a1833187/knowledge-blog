### 由于并发执行多个事务而导致预料结果与最终结果不同的"误操作"

1. 丢失修改

   两个事务同时对一个数据进行更新操作,导致最终只返回最后一次更新后的结果

   例如:

   余额1000-->事务1取出100,事务2取出50---->预期结果:余额为850;实际结果:余额为900或950,因为只返回一个结果,其中一个结果被丢失了.

2. 脏读

   一个事务读取了另一个事务修改后但未提交的数据.

   例如:

   事务A对数据进行了更新--->事务B读取了事务A更新后的数据---->事务A发生了回滚(rollback)导致本次修改无效--->事务B读到了"脏数据"

3. 不可重复读

   对一个数据进行多次读取,前后读取到的结果不相同.注**:这里的结果不相同是指记录集合中某些记录的值发生了该表,记录集合中记录的总条数没有发生改变.**

   例如:

   事务A对数据进行读取得到值1----->事务B将数据修改为了2并提交---->事务A再次对数据读取得到值2.

4. 幻读

   对一个记录集合进行多次读取,由于其他事务向记录集合中插入了新的记录导致前后读取到的结果不相同.注:**这里的结果不相同是指记录集合中记录的总条数发生了改变**

   例如:

   事务A读取到了记录集合A(A中有3条记录)---->事务B向记录集合中插入了一条记录---->事务A读取到了记录集合A(A中有4条记录)

### MySQL中针对"误操作"的隔离级别

1. read uncommited

   不提交读:这种是隔离级别最低的.并不能解决上述的任意一个"误操作".但并发执行的效率最高.

2. read commited

   提交读:指一个事务提交之后,它对数据做的变更才能被其他事物读取到.

   可以解决脏读.

3. read repeatable

   可重复读: 一个事务执行过程中看到的数据一直跟这个事务启动时看到的数据是一致的.

   可以解决脏读,不可重复读

4. serializable

   串行化:会对记录加上读写锁,在多个事务对这条记录进行读写操作时,如果发生了读写冲突,后访问的事务会等待前一个事务完全结束后再执行.

   可以解决脏读,不可重复读,幻读.但执行的效率最低.

   | **误读/隔离级别** | **read uncommitted** | **read committed** | **read repeatable** | **serializable** |
   | ----------------- | -------------------- | ------------------ | ------------------- | ---------------- |
   | **脏读**          | **false**            | **true**           | **true**            | **true**         |
   | **不可重复读**    | **false**            | **false**          | **true**            | **true**         |
   | **幻读**          | **false**            | **false**          | **false**           | **true**         |


### 两种锁以及三层封锁协议

#### 两种锁

1. 排它锁(x锁):当事务对数据加上x锁后,其他事务不能再对该数据加任何锁,其他事物不能对该数据进行任何写操作,**但是可以进行不加锁的读操作**.

2. 共享锁(s锁):当事务对数据加上s锁后,事务(任何一个)不能对数据加x锁,不能对该数据进行任何写操作,**但可以对该数据加s锁,也可以执行读操作.**

   ![1653998448758](C:\Users\qiu\AppData\Roaming\Typora\typora-user-images\1653998448758.png)

#### 三层封锁协议

1. 一级封锁协议:当事务对数据进行写操作时,必须加上排它锁,且这个锁只有该事务结束后才被释放.

   **一级封锁协议可以解决丢失修改的问题**:因为当两个事务同时对一个数据进行修改时,前面的事务对数据加上x锁后,后一个事务就无法再加锁,也就无法对数据进行修改操作.

   **一级封锁协议无法解决脏读的问题**:当事务A对数据加上排它锁并进行读写操作时,事务B仍可以通过不加锁的读来读取到该数据,因此也可能读到事务A修改中间过程中的数据.

2. 二级封锁协议:当事务对数据进行写操作是,必须加上排它锁,且这个锁只有该事务结束后才被释放;当事务对数据进行读操作时,必须加上共享锁,且该共享锁随着读操作的结束而被释放.

   **二级封锁协议可以解决脏读的问题**:当事务A对数据加上排它锁并进行读写操作时,事务B若想要读取数据,必须加上共享锁,但由于该数据已经被加上排它锁,而排它锁与其他所不兼容,所以事务B无法成功给数据加上共享锁,因此也就不能再事务A修改的中间过程中读取到数据,只有事务A结束以后,事务B才能读取到数据.

   **二级封锁协议不可以解决不可重复读的问题**:在事务A对数据加上排它锁并进行读写操作之前,事务B可以加上共享锁读取该数据,然后将共享锁释放,然后事务A再进行读写操作,当事务A结束后,事务B再加上共享锁读取经过事务A处理后的数据.前后两次得到的数据是不一致的.

3. 三级封锁协议:当事务对数据进行写操作时,必须加上排它锁,且这个排它锁只有在该事务结束后才被释放;当事务对数据进行读操作时,必须加上共享锁,且该共享锁只有在该事务结束后才被释放.

   **三级封锁协议可以解决不可重复读的问题:**当事务A读取数据时,需要对该数据加上共享锁,由于共享锁与排它锁不兼容,所以在事务A结束之前,其他事务无法对该数据加上排它锁,也就无法进行写操作,同时由于事务A对数据加上了共享锁,所以事务A本身也无法对数据进行写操作.所以在整个事务A的过程中,读取到的数据都是一致的.


| 误读/封锁协议类型 | 一级封锁协议 | 二级封锁协议 | 三级封锁协议 |
| ----------------- | ------------ | ------------ | ------------ |
| **丢失修改**      | **true**     | **true**     | **true**     |
| **脏读**          | **false**    | **true**     | **true**     |
| **不可重复读**    | **false**    | **false**    | **true**     |

