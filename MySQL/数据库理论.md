# 数据库理论

## SQL语句

1. 创建数据库

   1. SSMS:在数据库右键选择"新建数据库"即可.

   2. SQL

      ```sql
      create database 数据库名
      on(
          //数据库文件信息
      	name = "",
          filename = "",
          size = int,
          maxsize = max,
          filegrowth = k)
      log on
      (
          //日志文件信息
      	name = "",
          filename = "",
          size = int,
          maxsize = max,
          filegrowth = k)
      ```

2. 表操作

   1. 创建表

      ```sql
      create table 表名(各种字段以及字段的属性)
      default('') //默认值
      check(字段 = '' or 字段 = ''....) //取值范围
      primary key 主键
      not null 非空
      ```

   2. 对表结构进行操作(一般是列(属性))

      1. 增

         ```mysql
         alter table 表名 add 属性名 属性数据类型 添加的位置(first,after 某一列之后);
         #如：
         alter table student add id int first;
         alter table student add name varchar(20) after student;
         ```

      2. 删

         ```mysql
         alter table 表名 drop 属性名;
         #如：
         alter table student drop id;
         ```

      3. 改字段

         ```mysql
         修改字段的类型
         alter table 表名 modify 字段名 字段的新类型;
         #如：
         alter table student modify id int auto_increment primary key;
         ```



         ```mysql
         修改字段的名称
         alter table 表名 change 字段名 新字段名 新字段的类型;
         #如：
         alter table 表名 change id sId int;
         ```
    
      4. 改表名
    
         ```mysql
         alter table 表名 rename to 新表名;
         #如：
         alter table student rename to student_SS;
         ```

   3. 添加记录

      ```sql
      insert into 表名 values();
      ```

   4. 查询

      ```sql
      select * from where 字段 = ''
      ```

   5. 删除记录

      ```sql
      delete from 表名 where 字段 = ''
      ```

   6. 更新记录

      ```sql
      update 表名 set 列名 = 新值 where...
      ```

7. 四种连接

   1. 内连接:只表示两张表共有的记录

      ```sql
      select * from 表1 inner join 表2 on 表1.属性名1 = 表2.属性名1
      //on后是匹配条件
      ```

   2. 外连接

      1. 左外连接:左边的表全部显示,右边的表如果匹配则显示,不匹配则显示为空值

         ```sql
         select * from 表1 left outer join 表2 on 表1.属性名1 = 表2.属性名1
         ```

      2. 右外连接与左外连接刚好相反

         ```sql
         select * from 表1 right outer join 表2 on 表1.属性名1 = 表2.属性名1
         ```

   3. 完全外连接:左边的表与右边的表均完全显示,不匹配的值显示为空值.

      ```sql
      select * from 表1 full outer join 表2 on 表1.属性名1 = 表2.属性名1
      ```

8. 基本查询

   1. 查询某个属性且该属性不能重复显示

      ```sql
      select distinct 属性名 from 表名
      ```

   2. 给属性换名

      ```sql
      select 属性名 新名 from 表名
      ```

   3. 按照某个属性排序

      ```sql
      select * from 表名 order by 属性名 asc/desc //默认为asc
      ```

   4. 通配符检索

      ```sql
      select * from 表名 where 属性名 like '_['值1','值2',...]%'
      //_匹配1个字符,%匹配一个或多个字符,[]中的值是或的意思.
      ```

   5. 分组统计

      ```sql
      select * from 表名 group by 属性名(可以是多个)
      ```

   6. 分组筛选

      ```sql
      select * from 表名 group by 属性名 having 筛选规则.
      一个人某个属性均超过k  min(属性) > k
      ```

9. 高级查询

   1. 嵌套查询

      ```sql
      select 属性名1 from 表1名 where 属性名2 in(select 属性名2 from 表2名 where 属性名3 in....)
      //嵌套的规则是where后的属性名要和in中查询的属性名相匹配
      ```

   2. 查询教授两门课且第一门课比第二门课高的老师的教师号

      ```sql
      select a.教师号 from (select 教师号,授课时长 from 授课表 where 课程号 = 第一门课 a),(select 教师号,授课时长 from 授课表 where 课程号 = 第二门课 b) where a.授课时长 > b.授课时长 and a.教师号 = b.教师号
      //a和b是别名
      可以分别只有这两门课的表里查询然后根据某些条件再合起来.
      ```

   3. 查询既教授A课程又教授B课程的教师姓名

      ```sql
      select 教师姓名 from 教师表 where 课程号 in(select 课程号 from 课程表 where 课程名 = 'A' intersect select 课程号 from 课程表 where 课程名 = ''B);
      //用交集实现
      ```

   4. 查询教授了所有课程的教师号

      ```sql
      select 教师号 from 教师表 where not exists(select * from 课程表 where not exists(select * from 授课表 where 教师号 = 教师表.教师号 and 课程号 = 课程表.课程号))
      ```

## 数据库知识点

**概念纲领：**

数据库的4个基本概念（数据、数据库、数据库管理系统、数据库系统)

> 数据是数据库中存储的基本对象
>
> 数据定义:描述事物的符号记录
>
> 数据种类:数字,文字,图形,音频等等
>
> 数据的含义被称为数据的语义



> 数据库:是长期存储在计算机内,有组织的,可共享的大量数据的集合
>
> 数据库的基本特征:
>
> 1. 数据按一定的数据模型组织,	描述和储存
> 2. 可为各种用户共享,冗余度较小,易扩展
> 3. 数据独立性较高



> 数据库管理系统:位于用户与操作系统之间的一层数据管理软件.是基础软件,是一个大型复杂的软件系统
>
> 数据库管理系统的用途:科学的组织和存储数据,高效的获取和维护数据
>
> 数据库管理系统的主要功能
>
> 1. 数据定义功能
>    1. 提供数据定义语言(DDL)
>    2. 定义数据库的数据对象
> 2. 数据组织,存储和管理
>    1. 分类,组织和管理各种数据
>    2. 确定数据在存储级别上的结构和存储方式
>    3. 实现数据之间的联系
>    4. 提供多种存取方法存取效率
> 3. 数据操纵功能
>    1. 提供数据操纵语言(DML)
>    2. 实现对数据库的基本操作(增删查改)
> 4. 数据库的事务管理和运行管理
>    1. 数据的安全性,完整性,多用户对数据的并发使用
>    2. 发生故障后的系统恢复数据库
> 5. 数据库的建立和维护功能
> 6. 其他功能



> 数据库系统:指在计算机系统中引入数据库后的系统构成,在不引起混淆的情况下常常把数据库系统简称为数据库
>
> 数据库系统的构成
>
> 1. 数据库
> 2. 数据库管理系统
> 3. 应用程序
> 4. 数据库管理员

数据库系统的特点

> 1. 数据结构化
> 2. 数据的共享性高,冗余度低且易扩充
> 3. 数据独立性高
> 4. 数据由数据库管理系统同一管理和控制

数据独立性

> 1. 物理独立性:用户的应用程序和存储在硬盘上的数据库中的数据是相互独立的
> 2. 逻辑独立性:用户的应用程序和数据的逻辑结构是相互独立的.
>
> 数据独立性由数据库管理系统的二级映射功能来保证

**数据模型**是数据库系统的**核心和基础**

**数据库系统的三级模式结构（三级模式、二级映像）**

> 基本概念:
>
> 模式:是对数据库逻辑结构和特征的描述;是型的描述,不涉及具体值;模式是相对稳定的
>
> 实例:数据库某一时刻的状态,随数据库的更新而不断变动  
>
> 三级模式
>
> 1. 模式:也称为逻辑模式.是数据库中全体数据的逻辑结构和特征的描述;所有用户的公共视图.
>
>    一个应用数据库一般只有1个模式
>
>    模式是数据库系统模式结构的中心
>
>    定义模式:
>
>    1. DDL定义数据的逻辑结构
>    2. 定义数据之间的联系
>    3. 定义与数据有关的安全性,完整性要求
>
> 2. 外模式:也称为子模式或用户模式,数据库用户使用的局部数据的逻辑结构和特征的描述;数据库用户的数据视图与某一应用有关的数据的逻辑表示.
>
>    外模式与模式的联系
>
>    1. 外模式通常是模式的子集,一个模式可以有多个外模式
>    2. 模式中某一数据在不同的外模式中可以有不同的体现
>
>    外模式的用途
>
>    1. 简化用户视图
>    2. 保证数据库安全性的一个有力措施
>
> 3. 内模式:也称为存储模式,是数据物理结构和存储方式的描述;是数据在数据库内部的表示方法
>
>    一个数据库只有1个内模式
>
>  
>
> 二级映像
>
> 外模式/模式映像
>
> 这种映像通常定义在各外模式的描述中.有多个映像
>
> 保证了数据的逻辑独立性:当模式改变,只需要改变映像,不需要改变外模式(应用程序是基于外模式编写的,所以也不需要改变应用程序)
>
> 模式/内模式映像
>
> 定义了数据全局逻辑结构和存储结构之间的联系
>
> 在数据库中该映像是唯一的.通常定义在模式中.
>
> 保证了数据的物理独立性:数据的存储结构发生改变,只需要改变映像,不需要改变模式
>
>  
>
> 二级映像的作用
>
> 1. 保证了应用程序的稳定性
> 2. 从以程序为中心改变为以数据为中心
> 3. 数据的存取由数据库管理系统管理,简化了应用程序的编制,减少了应用程序的维护与修改

**关系模型（三要素）**

> 关系数据库系统采用关系模型作为数据的组织形式
>
> 三要素:关系数据结构,关系操作,完整性约束
>
> 关系数据结构
>
> > 1. 域:字段值的取值范围
> > 2. 笛卡尔积:所有域的所有值的任意组合,可以看做是关系的"域".其表示方法可以看做是一张二维表,其中每一类列为一个域,每一行为一个元组
> > 3. 关系:笛卡尔积的一个子集
> > 4. 元组:关系中的每个元素叫做n元组 
> > 5. 属性:关系中每列
> > 6. 码
> >    1. 候选码:能够唯一标识一个实体,可以有多个
> >    2. 主码:从若干候选码出选出一种作为主码
> > 7. 主属性:候选码中的众多属性称为主属性
>
> 关系操作
>
> > 关系代数是一种抽象的查询语言,用对关系的运算来表达查询
> >
> > 关系代数的运算法:集合运算符(并,交,差,笛卡尔积)和专门的运算符(选择(σ),投影,连接,除)
> >
> > 选择(σ):从一个关系中选出若干符合条件的元组
> >
> > 投影(π):从一个关系中选出若干属性列组成新的关系.投影之后不仅取消了原关系中的某些列,而且还可能取消某些元组(避免重复行),比如:把主码列删掉,剩下的属性中可能出现两个元组重复,则删除掉一个元组
> >
> > 连接(θ) join:表示两个关系的串接
> >
> > 等值连接(两个关系中某个属性值相等),自然连接(某种比较情况下的连接且去掉重复列)
> >
> > 外连接:完全外连接,左外连接,右外连接
>
> 优点:建立在严格的数学基础上;概念单一:实体和各类联系都用关系表示
>
> 缺点:查询效率较低,为提高查询效率,对用户的查询请求进行优化,增加了开发数据库管理系统的难度

**关系的概念、属性、元组、码（关键字）、主码、主属性**

> 关系:一个关系对应通常的一张表
>
> 属性:表中一列即为一个属性,给每一个属性起一个名称即为属性名
>
> 元组:表中的一行
>
> 主码:也称码键.表中的某一个属性组,它可以唯一确定一个元组

**关系的完整性（实体完整性、参照完整性、用户定义完整性）**

> 实体完整性和参照完整性是关系的两个不变性能
>
> 实体完整性:指关系的主关键字不能重复也不能取空值
>
> 参照完整性:定义建立关系之间联系的主关键字和外部关键字引用的约束条件
>
> 域完整性:保证数据库字段取值的合理性
>
> 用户定义的完整性(非必须):根据实际需要对某一具体应用设计的数据作出约束性条件





**SQL语句（功能、定义表、查询--通配符、空值、删除、外连接、ANY和ALL谓词）**

SQL:结构化查询语言,是关系数据库的标准语言

SQL的特点

> 1. 综合统一
> 2. 高度非过程化
> 3. 面向集合的操作方式
> 4. 以同一种语法结构提供多种使用方式
> 5. 语言简洁,易学易用

SQL的功能

![1655286855136](C:\Users\qiu\AppData\Roaming\Typora\typora-user-images\1655286855136.png)

数据定义

> 表定义:create table 表名(列名 数据类型 列级完整性约束条件,.....表级完整性约束条件)  表级完整性约束:外键(foreign key(外键属性名) references 该表名(某个属性名))   注:当一个表中有多个主码(不是主键)时,该约束属于表级完整性约束:primary key(属性名1,...属性名n)
>
> 模式定义:create schema 模式名 authorization 用户名   当没有指定模式名时,模式名缺省为用户名.可以在模式定义后面直接对表或视图进行定义
>
> 删除模式:drop schema 模式名 cascade/	restrict    cascade:删除模式的同时把模式下所有的数据库对象全部删除.   restrict:只有该模式下所有数据库对象都被删除掉的前提下该模式才可以成功删除
>
> 修改表:
>
> ![1654931203268](C:\Users\qiu\AppData\Roaming\Typora\typora-user-images\1654931203268.png)

数据查询

> **单表查询**
>
> 格式:select (显示的属性列) from (查询对象) where (查询条件) group by (按照某个条件分组) having (分组的条件) order by(按照某个属性排序)
>
> 消除重复:select distinct ... from ..
>
> like  字符匹配  通配符:%:0或多个字符,_:1个字符   escape '\\':表示\\为换码字符(转义字符)
>
> 聚集函数
>
> count(distinct/all(缺省为all) 列名)
>
> ..
>
> 对表作分组后(group by),聚集函数只作用于某个具体的分组
>
> 注意:where子句中不能用聚集函数作为条件表达式
>
> **连接查询**:SQL中连接是用"连接条件"来表示的
>
> 等值连接:select ...from 表名1,表名2 where 表名1.属性名1 = 表名2.属性名2
>
> 外连接:将所有组合结果输出出来(见上)
>
> **嵌套查询**
>
> 将一个查询块嵌套在另一个嵌套块中的where或having 语句中叫嵌套查询.**order by只能在最外层嵌套查询**	
>
> 1. 不相关子查询:子查询的条件不依赖父查询.由里到外
> 2. 相关子查询:子查询的查询条件依赖父查询
>
>  
>
> 1. 带有in谓词的子查询
>
>    当内层集合的结果是一个集合时可以用带有in谓词的子查询
>
>    带有in谓词的子查询往往可以通过等值连接查询等价
>
> 2. 带有比较运算符的子查询
>
>    当内层集合是一个确定的单值时可以用比较运算符
>
> 3. 带有any(some) 或 all的子查询
>
>    > \> any:大于子查询中某个值
>    >
>    > \> all:大于子查询中的所有值
>
> 4. 带有exists谓词的子查询
>
>    带有exists谓词的子查询不返回任何数据,只产生true(内层查询结果非空) Or false(内层查询结果为空)
>
>    由exists引出的子查询,其目标列表达式通常是*,因为不返回任何有意义的数据,单独取某个列名无意义
>
>    用exists实现全称量词(难点):任意x:p   --->  not( 存在x:not p)  用两个not exists代替
>
>    用exists实现蕴含(->)(难点): 任意x  p -> q   ---->   not  存在x: (p ∩ not q)   一个not exists p  and not exists
>
>    不同查询之间的转换
>
>    1. 一些带有exists/not exists谓词的子查询不能被别的形式的子查询代替
>    2. 带有in谓词,比较运算符,any,all的子查询都能用带exists谓词的子查询代替
>
> **集合查询**
>
> 并操作:union:将多个查询结果合并起来,系统自动去掉重复元祖(若是不想去掉重复元祖可以用union all)
>
> 交操作:intersect
>
> 差操作:except

数据更新

> 插入语句:
>
> insert into 表名 values(各种值)
>
> 将子查询的结果插入表中:insert into 表名(子查询结果的属性参数) 子查询语句(select ....)
>
> 插入的结果不能破坏表本身的实体完整性,参照完整性以及用户定义的完整性
>
> 更新语句:
>
> update 表名 set 列名 = 修改成什么值 where 哪个元组要修改
>
> 修改时不能破坏实体完整性,主码不能修改,不能破坏用户定义的完整性
>
> 删除语句:
>
> delete from 表名 where ..

空值处理

空值就是不知道或者不存在或者无意义的值

1. 该属性应该有一个值,但目前不知道它的具体值
2. 该属性不应该有值
3. 由于某种原因不便于填写

空值的运算

1. 空值与另一个值的算术运算结果为空值
2. 空值与另一个值比较运算的结果为unknown

**视图（定义、作用）**

定义:create view 视图名(列名,列名..) as 子查询 with check option(对视图进行操作时要满足子查询的条件表达式)

删除:drop view 视图名 (cascade/restrict)        cascade是删除引用该视图的所有视图,restrict是指如果有其他视图引用该视图,则删除视图失败

作用(看仔细)

> 1. 能够简化用户的操作
> 2. 使用户能够以多种角度看待同一数据
> 3. 对重构数据库提供了一定程度的逻辑独立性
> 4. 能够对机密数据提供安全保护
> 5. 适当的利用视图可以更清晰的表达查询

特点:从一个表或几个表导出的虚表(数据库中只存放视图的定义不存放视图的数据)

==================================

**关系数据理论（规范目的、函数依赖、范式--1NF、2NF、3NF、BCNF、模式分解准则）**

规范目的: 用规范化理论改造关系模式,消除其中不合适的数据依赖,设计一种好的数据逻辑模式

规范化的基本思想:逐步消除数据依赖中不合适的部分,使模式中的各关系模式达到某种程度的"分离"

采用"一事一地"的模式设计原则

规范化实质上是指概念的单一化

数据依赖:y = f(x), x --> y(x唯一确定y,y依赖x)

数据依赖是完整性约束的一种表现形式

数据依赖类型

> **函数依赖**
>
> 定义:设R(U)是一个属性集U上的关系模式,X和Y是U上的子集,对于R(U)上任意一个可能的关系r,r中不可能存在两个元组在X上的属性值相等,而在Y上的属性值不等则称"**X函数确定Y**"或"**Y函数依赖X**",记作X->Y,X为这个函数依赖的**决定属性组**,也称为**决定因素**
>
> > 平凡函数依赖和非平凡函数依赖
> >
> > > 平凡函数依赖:X->Y,Y∈X,X->Y是平凡函数依赖(这个没有啥研究价值..)
> > >
> > > 非平凡函数依赖:X->Y,Y∉X,X->Y是非平凡函数依赖
> >
> > 完全函数依赖和部分函数依赖
> >
> > > 完全函数依赖:X->Y,且对于X的任何一个真子集X',X'-\\>Y,称Y完全依赖于X
> > >
> > > 部分函数依赖:与完全函数依赖相反
> >
> > 传递函数依赖:X->Y,(Y∉X),Y-\\>X,Y->Z,称Z传递函数依赖X,如果Y->X,即X<-->Y,则Z直接函数依赖X
> >
> >  
> >
> > 码
> >
> > > 候选码:K为关系R(U,F)中的属性或属性组合,若U完全函数依赖K,则K为R的一个候选码
> > >
> > > 若U部分函数依赖K,则K为R的一个超码
> > >
> > > 候选码是最小的超码,候选码的任何一个真子集都不是候选码
> > >
> > > 主码:从多个候选码中选出一个候选码作为主码
> > >
> > > 主属性:包含在任何一个候选码中的属性
> > >
> > > 非主属性:不包含在任何一个候选码中的属性
> > >
> > > 全码:整个属性组是一个候选码
> > >
> > > 外码:关系R(U,F)中,U中属性X并非R中的码,而是另一个关系模式的码,则称X是R的外码
>
>  
>
> 范式
>
> 定义:符合某一种级别的关系模式的集合
>
> 低级范式包含高级范式
>
> > 1NF:如果一个关系模式R中所有属性都是不可分的基本数据项,则R∈1NF
> >
> > 2NF: 关系模式R∈1NF,并且每一个非主属性都完全函数依赖于R的码,则R∈2NF
> >
> > 3NF:关系模式R∈2NF,并且不存在非主属性传递函数依赖于R的码,则R∈3NF
> >
> > BCNF(修正的第三范式):关系模式R(U,F)∈1NF,如果对于R中的每个函数依赖X->Y,X必含有码,那么R∈BCNF
>
> 关系模式规范化
>
> ![1655113281028](C:\Users\qiu\AppData\Roaming\Typora\typora-user-images\1655113281028.png)
>
> 关系模式分解原则是模式分解具有无损连接性，模式分解能够保持函数依赖。(学习通上的幻灯片)
>
> 1NF->2NF:将存在部分函数依赖的关系的左边集合的所有非空子集列出来,然后按照R将每个属性列在对应真子集之后
>
> 如:AC --> B A--> D,原来的表是(A,B,C,D),拆分真子集并组装后变成(A,D),(A,C,B)
>
> 2NF->3NF:将存在传递关系的后半部分单独拿出来成一个关系,前面的成一个关系
>
> 如:A-->B  B-->C,原来的表是(A,B,C) 分解以后  (A,B) (B,C)
>

**数据库设计（设计步骤，概念模型E-R图(实体-联系方法)、逻辑模型）**

数据库设计:对于一个指定应用环境,设计一个优良的数据库逻辑模式和物理结构,并据此建立数据库及应用系统,使之能够有效地存储和管理数据,满足各种用户的应用需求,包括信息管理和数据处理要求

数据库设计的基本规律

> 三分技术 七分管理 十二分基础数据
>
> 管理:数据库建设项目管理;企业的业务管理
>
> 基础数据:数据的收集,整理,组织和不断更新

数据库设计

2个步骤

> 静态结构设计
>
> 动态结构设计

4个步骤

> 需求分析
>
> 概念结构设计
>
> 逻辑结构设计
>
> 物理结构设计

6个步骤

> 1. 需求分析
>
>    设计描述:数据字典,全系统中数据项,数据结构,数据流,数据存储的描述
>
> 2. 概念结构设计
>
>    概念模型:将需求分析得到的用户需求抽象为信息结构
>
>    概念模型用途
>
>    > 1. 用于信息世界的建模
>    > 2. 是现实世界到机器世界的一个中间层次
>    > 3. 是数据库设计的强有力工具
>    > 4. 数据库设计人员和用户之间交流的语言
>
>    设计描述:E-R图
>
>    > 实体之间的联系
>    >
>    > > 一对一:对于实体集A中的每一个实体,实体集B中最多有一个实体(也可以没有)与之联系,反之亦然,则A和B是一对一联系(1:1)
>    > >
>    > > 一对多:对于实体集A中的每一个实体,实体集B中有n(n>=0)个实体与之联系,反之对于B中的每一个实体,实体集A中最多有一个实体与之联系.则A和B是一对多联系(1:n)
>    > >
>    > > 多对多:......
>    >
>    > 把参与联系的实体型的数目称为联系的度
>    >
>    > E-R图:提供了表示实体性,属性和联系的方法
>    >
>    > > 实体性:用矩形表示,矩形框内写明实体名
>    > >
>    > > 属性:用椭圆形表示,并用无向边将其与相应的实体型连接起来
>    > >
>    > > 联系:用菱形表示,菱形框内写明联系名,并用无向边分别与有关实体型连接起来,同时在无向边旁标上联系的类型(**联系可以具有属性**)
>
> 3. 逻辑结构设计
>
>    > E-R图向关系模型的转换
>    >
>    > 1. 实体型的转换:1个实体型转换为1个关系模式(属性和属性相对应,码和码相对应)
>    > 2. 实体型件的联系
>    >    1. 一对一
>    >       1. 转换为一个独立的关系模式,关系模式的属性是与联系相连的实体的属性以及联系本身的属性;候选码包括联系中每个实体的码
>    >       2. 也可以与相连的任意一端对应的关系模式合并.关系模式的属性和码为本端实体的属性和码加上另一段实体的属性和码
>    >    2. 一对多
>    >       1. 转换为一个独立的关系模式,关系模式中的码为一对多联系中为一的实体的码
>    >       2. 与n端实体合并.
>    >    3. 多对多
>    >       1. 转换为一个独立的关系模式
>    >    4. 基于相同码的关系模式合并:将其中一个关系模式的属性加入到另一个关系模式中,去掉同义属性,适当调整顺序
>
> 4. 物理结构设计
>
> 5. 数据库实施阶段
>
> 6. 数据库运行和维护阶段

=========================================

**备份与恢复（事务定义、事务特征、故障的种类、日志、备份策略、检查点技术）**

1. 事务:用户定义的一个数据库操作序列,这些操作要么全做,要么都不做,是一个不可分割的工作单位

   1. 事务是恢复和并发控制的基本单位
   2. 事务定义
      1. 显示定义:begin transaction   ...  commit/rollback
      2. 隐式定义:数据库管理系统按缺省规定自动划分事务
   3. 事务的特性(ACID)
      1. 原子性
      2. 持续性
      3. 隔离性
      4. 一致性

2. 故障种类

   1. 事务内部故障.  事务故障的恢复:事务撤销:强行回滚

      > 运算溢出
      >
      > 并发事务发生死锁而被选中撤销该事务
      >
      > 违反了某些完整性限制

   2. 系统故障           系统故障的恢复:重启系统后,将**所有非正常终止的事务回滚**;若某些事务完成但其数据没有被存储到硬盘中,则**重做所有这部分已经提交的事务**
      1. 特定类型的硬件故障
      2. 操作系统故障
      3. 数据库管理系统代码错误
      4. 系统断电

   3. 介质故障
      1. 磁盘损坏
      2. 磁头碰撞
      3. 瞬时磁场干扰

   4. 计算机病毒

3. 恢复的实现技术

   1. 如何建立冗余数据

      1. 数据转储

         定义:DBA定期将整个数据库复制到磁带,磁盘等存储介质上保存起来的过程

         相关转储方法

         1. 静态转储和动态转储

            1. 静态转储:系统中无运行事务时进行的转储操作(转储期间不允许对数据库操作)

            2. 动态转储:转储操作与用户事务并发运行(转储期间允许对数据库操作)

               动态转储后的数据库不能满足数据一致性操作,如果想要保障数据一致性,则需要搭配记录了转储期间各个事务运行的日志文件

         2. 海量转储和增量转储

            1. 海量转储:每次转储全部数据库
            2. 增量转储:每次只转储上次转储后更新的数据

      2. 登记日志文件

         日志文件:用来记录事务对数据库的更新操作的文件

         格式

         1. 以记录为单位的日志文件

            各个事务的开始标记:begin transaction;各个事务的结束标记(commit/rollback);各个事务的所有更新操作:事务标识,操作类型,操作对象,更新前数据的旧值,更新后数据的新值

         2. 以数据块为单位的日志文件

            事务标识和被更新的数据块

         日志文件的作用

         1. 进行事务故障恢复
         2. 进行系统故障恢复

         为保证数据库是可恢复的,登记日志文件必须遵循的两条规则

         1. 登记的次序严格按并发事务执行的时间次序
         2. 必须先写日志文件,后写数据库

   2. 如何利用这些冗余数据实施数据库恢复

      1. 事务故障的恢复

         由恢复子系统利用日志文件撤销事务对数据库的修改

         1. 反向扫描日志文件,查找该事务的更新操作
         2. 对该事务的更新操作执行逆操作
         3. 重复步骤1,2直到事务的开始标记

      2. 系统故障的恢复

         撤销所有未完成(undo)的事务;重新执行已经完成事务(redo)

         1. 正向扫描日志文件,找出undo(只有begin transaction,没有commit)和redo(都有)的事务,将undo事务和redo事务分别放到undo队列和redo队列
         2. 对撤销队列进行撤销处理:反向扫描日志文件,对队列中的每个事务执行逆操作知道事务开始标记
         3. 对重做队列进行重做处理:正向扫描日志文件,对队列中每个事务执行相应的操作

      3. 介质故障的恢复

         重装数据库,重做已完成的事务

   3. 具有检查点的恢复策略

      目的:提高系统故障恢复的效率

      检查点记录的内容

      1. 建立检查点时刻所有正在执行的事务清单
      2. 这些事务最近一个日志记录的地址

      重新开始文件的内容:记录各个检查点在日志文件中的地址

      动态维护日志文件的方法:周期执行建立检查点,保护数据库状态

      1. 将当前日志文件缓冲区中的所有日志记录写入磁盘的日志文件中
      2. 在日志文件中写入一个检查点记录
      3. 将当前数据缓冲区中的所有数据记录写入磁盘的数据库中
      4. 把检查点记录在日志文件中的地址写入一个重新开始文件

      ![1655029646266](C:\Users\qiu\AppData\Roaming\Typora\typora-user-images\1655029646266.png)

   4. 数据库镜像

      目的:提高介质故障恢复的效率

      定义:数据库管理系统自动把整个数据库或其中的关键数据复制到另一个硬盘上

   5. 日志备份种类

      > 1. 完整备份
      >
      >    就是对整个系统进行完全备份，包括系统和数据。
      >
      > 2. 差异备份
      >
      >    就是每次备份的数据是相对于上一次全备份之后增加和修改过的数据。
      >
      > 3. 日志备份
      >
      >    日志备份并不备份数据库本身，它只是备份日志记录，从而只备份上次备份之后到当前备份时间发生变化的日志内容。

**安全管理（主要技术、授权、角色）**

数据库安全性:指保护数据库以防止不合法使用所造成的数据泄露,更改和破坏. 系统安全保护措施是否有效是数据库系统主要的性能之一

数据库的不安全因素

> 1. 非授权用户对数据库的恶意存取和破坏.    安全措施:用户身份鉴别,视图,存取控制等
> 2. 数据库中重要或敏感的数据被泄露             安全措施:强制存取控制,数据加密存储,数据加密传输以及审计日志分析
> 3. 安全环境的脆弱性

安全管理的主要技术

1. 用户身份鉴别:系统提供的最外层安全保护措施.用户标识由用户名和用户标识号(在系统整个生命周期里唯一)组成

   1. 静态口令鉴别:用户自己设定,口令是静态不变的
   2. 动态口令鉴别:口令动态变化,每次鉴别需要使用动态产生的口令进行登录(一次一密)
   3. 智能卡鉴别:
   4. 生物特征鉴别

2. 存取控制

   1. 定义用户权限
   2. 合法权限检查

3. 自主存取控制方法(DAC):不同用户对不同数据对象有不同的存取权限,且用户之间可以转交权限.

   缺点:可能存在数据的"无意泄露"

4. 授权:授予与回收

   1. 授权:grant 权限.. 权限 on 对象类型  对象名.. to 用户 with grant option(如果有表示该用户可以传播该权限)              注:*不允许循环授权*,循环授权会导致回收权限失败
   2. 回收:revoke revoke 权限 .. 权限 on 对象类型 对象名  from 用户 cascade(回收该权限以及传播的所所有权限)/restrict(如果有传播的权限则回收失败)

5. 数据库角色

   1. 定义:被命名的一组与数据库操作有关的权限,是权限的集合,可以为一组具有相同权限的用户创建一个角色
   2. 角色创建:create role 角色名
   3. 给角色授权: grant 权限 on 对象类型 对象名 to 角色 with admin option(表示可以传播该权限)
   4. 将角色权利授予用户:grant 角色 on 用户1,用户2...
   5. 回收角色权限: revoke 权限 on 对象类型 对象名 from 角色
   6. 根据角色回收用户权限:revoke 角色 from 用户1(该用户本身在角色下)

6. 强制存取控制(MAC):

   1. 主体只能读取客体中比其密级低的数据
   2. 仅当主体的许可证级别小于等于客体的密级,主体才能写相应的客体

7. 视图机制:实现授予用户某个表中某些行的权限

8. 审计:属于一种监控措施.

   1. 审计:audit 权限.. on 对象名
   2. 取消审计:noaudit 权限.. on 对象名

9. 数据加密:防止数据库中数据在存储和传输中失密的有效手段

**并发控制（不一致现象、封锁、冲突可串行化、死锁、两段锁协议）**

 不一致现象

> 1. 丢失修改:两个事务同时对一个数据修改,其中一个事务的提交结果破坏了另一个事务的提交结果 ,导致其中一个事务的丢失修改
> 2. 不可重复读:指事务T1读取数据后,T2执行更新(修改,删除,插入)操作,使T1无法再现前一次读取结果.其中删除,插入导致数据的记录数量发生改变,也被称为"幻读"
> 3. 读脏数据:事务T1修改数据,T2读取该数据,T1执行回滚导致此次数据修改无效,而T2读取的数据是无效数据

封锁

> 定义:事务T在对某个数据操作之前,向系统发出请求,对数据加锁.在事务T释放锁之前,其他事务不能更新此数据
>
> 基本封锁类型
>
> > 排它锁:事务T对数据A加X锁,只允许事务T修改数据A,其他事务不能对数据A加上任何类型的锁,不能读取和修改数据A
> >
> > 共享锁:事务T对数据A加S锁,事务T只能读取数据A,其他事务可对数据加上S锁,可以读取数据A
>
> 封锁协议:运用X锁和S锁按照一定的规则对数据加锁
>
> 三级封锁协议
>
> > 一级封锁协议:事务T在修改数据R之前必须加上X锁,直到事务结束才释放.
> >
> > 可以解决"丢失修改"的问题,不能解决脏读和不可重复读
> >
> > 二级封锁协议:一级封锁协议加上事务T在读取数据R之前要加上S锁,在读取完毕后释放S锁
> >
> > 可以解决"丢失修改"和"脏读",不能解决不可重复读
> >
> > 三级封锁协议:一级封锁协议加上事务T在读取数据R之前要加上S锁,直到事务结束释放S锁
> >
> > 可以解决"丢失修改","脏读"和"不可重复读"
>
> 活锁和死锁
>
> > 活锁:持续等待获取锁但一直没有竞争到锁
> >
> > 解决活锁问题:遵循"先来先服务"的策略
> >
> > 死锁:多个事务都请求加锁且又都请求对已为其他事务封锁的数据对象加锁,从而出现死等待
> >
> > 解决死锁问题
> >
> > > 死锁的预防:破坏产生死锁的条件
> > >
> > > 1. 一次封锁法:1个事务一次将所有要用的数据加锁,否则不执行
> > > 2. 顺序封锁法:预先对数据对象规定一个封锁顺序,所有事物按照这个封锁顺序进行封锁
> > >
> > > 死锁的诊断与解除
> > >
> > > 诊断
> > >
> > > 1. 超时法:设定一个事务的最长等待时间,如果超过,则认为发生了死锁
> > > 2. 事务等待图法:一个有向图,节点表示正在运行的事务,边表示事务之间的等待关系.定期检测如果发现图中出线回路这说明出现死锁
> > >
> > > 解除:选择一个处理锁代价最小的事务,将其撤销

并发调度的可串行性

> 可串行化调度:多个事务并发执行是正确的,当且仅当其结果与按某一次序串行执行这些结果相同
>
> 冲突可串行化调度:比可串行化更严格的条件.一个调度Sc在保证冲突操作的次序不变的情况下,通过交换两个事务不冲突操作的次序得到另一个调度Sc',如果Sc'是串行的,则称调度Sc是冲突可串行化调度

两段锁协议

使用两段锁协议实现并发调度可串行性

定义:所有事务必须分两个阶段对数据项进行加锁和解锁.在对任何数据进行读,写操作之前,事务首先要获得对该数据的加锁;释放一个封锁之后,事务不再申请和获得其他任何封锁

两段锁协议和可串行化调度的关系

![1655124116312](C:\Users\qiu\AppData\Roaming\Typora\typora-user-images\1655124116312.png)

理解使用：关系代数 