## 索引
### 介绍
+ 索引定义：索引对于MySQL而言就相当于一本书的目录，**通过某些数据结构来表示记录的相关的正，通过这些特征能够更快的找到相关记录，从而提高查找的效率**
+ 索引的好处：**能够大幅度提升查找的效率**。相较于内存中的查找，**MySQL中相关记录的查找往往需要在磁盘上通过IO流进行操作**，由于磁盘上操作的速度较内存中操作的速度要慢上3-4个数量级，在加上**数据量的庞大**，因此索引对查找的提升效率非常大。
+ 索引的适用场景：索引能够大幅度提高查找的效率，但同时也会导致数据的增、删、改的操作的效率降低，这是因为当数据发生变化时，索引也要相应的进行调整。因此**索引更适用于查找的次数远多于数据的变化的场景**。事实上，在实际需求场景中，我们进行的最多的操作是查找。
###  相关操作
+ 查看索引：show index from 表名    ![在这里插入图片描述](https://img-blog.csdnimg.cn/bf66d0c2f04a454f8bac157d600a5807.png)对于MySQL自带的primary key 和 unique约束是自带索引的。
+ 创建索引： create index 索引名字 on 表名(列名)![在这里插入图片描述](https://img-blog.csdnimg.cn/6a95a3afb5074450b03805eb4b8d6be9.png)
创建索引是一个非常低效的操作(因为数据量往往非常大), 因此最好要在表创建的时候将索引规划好。
+ 删除索引：drop index 索引名字 on 表名
![在这里插入图片描述](https://img-blog.csdnimg.cn/d7881f275e8248d8b40e7bce96d45d2d.png)

 	与创建索引一样，删除某个索引的名字是非常低效的。
###  本质(背后的数据结构)
+ 索引的本质
**索引的本质是b+树**。b+树是在b树(b-树)的基础上进行的某种调整得到的。因此，在介绍b+树之前，我们先介绍一下b树。
首先，**b树是一棵N叉搜索树，其中每一个节点存储了N个key值，这N个key值划分成了N+1个区间，而每一个区间对应的是一个子树**![在这里插入图片描述](https://img-blog.csdnimg.cn/55af47fbe37c433180e8e523604f0e07.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zua6JWk,size_20,color_FFFFFF,t_70,g_se,x_16)通过b树进行查找的过程与二叉搜索树类似，在查询某个key值时，按照b树从上到下，分别和每个节点中的key值划分的区间进行比较，然后将在key对应的更精细的范围区间的子树内查找。
**b+树相较于b树而言，每个节点存储的N个key值划分成N个区间，丢掉了最大的key值的右侧的区间；b树的父亲节点中的key值不在子节点中存储，而b+树中父亲节点中的最小值(或者最大值)要在子节点中进行体现；同时b+树中的叶子节点之间通过链表的形式进行相连。**![在这里插入图片描述](https://img-blog.csdnimg.cn/251fbf6e009447a6ada2d27e6191c745.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zua6JWk,size_20,color_FFFFFF,t_70,g_se,x_16)


+ b+树的优势
	我们常见的用于查找某个数据的结构有链表、顺序表、哈希表、二叉搜索树等等。相较于这些常见的数据结构，b+树更加适用于MySQL中数据的查询。
	1. **首先由于MySQL中数据量非常大，因此MySQL中数据的查询操作是在磁盘上进行的，同时MySQL中数据的查询要运用的是key值**，因此对于链表、顺序表这些在内存上通过下标进行元素查找的数据结构，显然是不是用于MySQL的。
	2. 我们都知道哈希表中数据的查询的时间复杂度为O(1),单从时间复杂度上看，哈希表是最优的，但**哈希表有一个缺点是只能进行等值查找而无法进行某个区间的范围查找**。因此也不适用于MySQL。
	3. 二叉搜索树其实是比较适合MySQL中数据的查找操作的，但因为是在磁盘上进行操作，而将庞大的数据分散到一棵二叉树上后，这棵二叉搜索树的高度(即在磁盘上进行操作的次数)仍然非常大。因此我们在二叉搜索树的基础上选择了b+树作为MySQL中索引的数据结构。
	4. 首先由于b+树中每个节点存储了多个key值，**因此整体上看b+树的高度是较少的**；同时由于待搜索的所有数据都存储在叶子节点中，因此**每次查询时的速度是稳定的**；同时叶子节点之间通过链表进行连接了之后能够**快速得进行范围查找**，比如要查找[k1,k2]之间的所有数据，只需要查找k1,k2两个值的位置，然后根据链表直接取这一段区间即可。
## 事务
### 介绍
+ **事务能够将数据库中多个独立的操作打包成一个整体**。事务中不同的操作存在一致性，即这些操作要么全部执行，要么全部不执行。 
### 特性
1. 原子性
	1. 定义:**保证了任务不可再被割分，并且任务中的所有操作要么要不都执行，要么都不执行**
	2. 原理:**维持事务原子性的核心是”回滚“**,事实上事务的原子性并不是真正的能够让若干操作做到同时进行，对于必须有先后执行顺序的操作而言，当前面的操作进行了之后，事务会对前面进行的操作进行记录，如果后面的操作不能正常进行，则事务会接受到反馈，将前面的操作进行"复原"。如图：![在这里插入图片描述](https://img-blog.csdnimg.cn/2d7ba2510ab0486dbd21b707e438daa1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zua6JWk,size_20,color_FFFFFF,t_70,g_se,x_16)

2. 一致性
		定义：事务执行前和执行后数据库中的数据均为合理合法的。
3. 持久性
		定义：事务执行后，被操作的数据会被写入到硬盘，因此数据被持久的存储下来。
4. **隔离性**
		1. 定义：**针对若干事务并发执行时产生的不同情况进行的不同程度的加锁，进而防止读取数据错误造成最终数据的错误。并发和隔离是不可兼得的，但两者并非绝对的限制，两者可以同时出现，依据不同场景来调节隔离的程度**
		2. 种类：在MySQL中对于事务的隔离程度提供了4种描述：**read uncommitted,read committed,repeatable read,serializable**。
			
			1. read uncommitted:允许读取未提交的数据，并发程度最高，隔离程度最低
			2. read committed：只允许读取提交后的数据，相当于只给写加锁。解决了脏读
			3.  repeatable read：给读和写同时加锁，解决了脏读和不可重复读
			4. serializable：串行化，解决了脏读、不可重复读和幻读
### 事务并发的问题
1. 脏读：
	1. 定义： **事务A在对数据进行修改时事务B对该数据进行了读取，该数据并非是最终的结果，而是一个临时的结果("脏数据")**。![在这里插入图片描述](https://img-blog.csdnimg.cn/00dd17f8482047e6b4845a6c29c7c46f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zua6JWk,size_20,color_FFFFFF,t_70,g_se,x_16)

	2. 解决办法：**给写加锁**，保证读只能在写操作进行完之后开始执行。
2. 不可重复读
	１.定义：**事务Ｂ进行多次读取的过程中，事务Ａ进行了多次写操作导致事务Ｂ中多次读取Ａ中的数据不一致**。![在这里插入图片描述](https://img-blog.csdnimg.cn/89ae0fe665154b51b620f634446340fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zua6JWk,size_20,color_FFFFFF,t_70,g_se,x_16)
	2. 解决办法：**同时给读和写加锁**，保证读和写同一份数据集时不能同时进行。
3. 幻读 
	1. 定义：**在多次查询时查询到的结果集并不相同**。将读和写加锁可以保证读和写同一份数据集时不能同时进行，但这种隔离并不是对数据库中的所有数据集进行了隔离，也就是说在对读和写加锁后写在读的同时也可以对其他数据集进行操作。![在这里插入图片描述](https://img-blog.csdnimg.cn/00d50aacf4a6494790d973e00952ab08.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zua6JWk,size_20,color_FFFFFF,t_70,g_se,x_16)

	2. 解决办法：**将读和写串行化**。即保证在写操作执行时，读操作必须在写操作执行之后才能执行，同样对于写而言也是如此。
## 总结
本篇文章主要讲述了MySQL中的索引和事务。**索引和事务属于数据库的原理层面的东西，同时也是面试中经常要考察的知识点**。希望大家能够有所收获！