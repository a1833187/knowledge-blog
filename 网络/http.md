# HTTP 

### 请求

1. 请求行(首行)

   1. HTTP的方法:描述这个请求.GET的意思是从服务器中获取到某个东西

   2. URL:描述了要访问的网络上的资源具体在哪

      > https://www.baidu.com/s?wd=%E4%B8%BA%E5%95%A5%E8%A6%81%E6%9C%89%E5%B1%80%E5%9F%9F%E7%BD%91&rsv_spt=1&rsv_iqid=0xdc5baacc001a6b7e&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_dl=tb&rsv_sug3=31&rsv_sug1=20&rsv_sug7=100&rsv_sug2=0&rsv_btype=i&prefixsug=%25E4%25B8%25BA%25E5%2595%25A5%25E8%25A6%2581%25E6%259C%2589%25E5%25B1%2580%25E5%259F%259F%25E7%25BD%2591&rsp=5&inputT=849079&rsv_sug4=8490781

      1. URL


         1. https:// , http:// , jdbc:mysql:// 协议方案名,描述这个URL是哪个协议使用的.
         2. www.baidu.com :服务器地址,表示当前要访问的主机是哪个,可以用域名,也可以用IP地址.
         3. 端口号:描述访问的是主机上的哪个程序.在浏览器中被省略了.然后会被赋予一个默认值(http是80,https是443)
         4. **/s:文件路径(编程常用)**:描述了当前要访问的服务器的资源.(这个文件可能是真实存在的,也可能是服务器代码产生的虚拟的动态数据)
         5. **?之后的部分:查询字符串(编程常用)**:程序员自己定义的给服务器传递的信息,相当于对获取到的资源提出了进一步的要求.以键值对的形式描述.多个键值对之间用&分割.
         6. 片段标识符(不常见):描述了要访问当前html页面中哪个具体的子部分,能够控制浏览器滚动到相对位置.相当于一个快速定位


​		2. URL encode/decode:对查询字符串中的特殊字符(比如? /等等)进行转义叫url encode,将转义后的内容还原回来叫url decode.如上述过程中的wd后面本来的内容时"为啥要有局域网",但被转义成了一堆字符.

​	3. 版本号

2. 请求头(header):包含了很多行,每一行都是一个键值对,中间用": "(有一个空格)隔开.
3. 空行:作为请求头的结束标记
4. 请求正文(body):客户端发送请求的具体内容.

### 响应

1. 响应行(首行)
   1. 版本号
   2. 状态码:描述这个响应是成功的还是失败的以及失败的原因.
   3. 状态码的描述:通过一系列单词描述当前状态码的含义.
2. 响应头(header):包含很多行,和请求中的请求头类似.
3. 空行:作为响应头的结束标记
4. 响应正文(body):服务器返回给客户端的数据,以多种形似返回,最常见的是html



HTTP 是 基于TCP实现的协议.所以HTTP也具有粘包问题:解决粘包问题的两种手段:1.分隔符.2.明确包长度.

对于GET请求,因为没有body,每个请求和每个请求之间可以通过空行 分割开

对于POST请求,在空行之后,还存在body,所以需要Content-Length来明确在空行之后再读取多少长度的body.



Content-Type:描述body中的格式.

1. application/x-www-form-urlencoded     form表单提交的数据格式
2. multipart/form-data   form表单提交,通常用于提交图片/文件
3. application/json  数据为json格式
4. text/html 数据为html格式

User-Agent:描述操作系统的类型,之前是为了方便网站开发人员充分了解某个设备是否支持js(还是仅支持文本操作),即要考虑浏览器的兼容性;现在的大部分浏览器都支持js,功能丰富,所以UA更多的是为了区分是PC端还是移动端.

Refer:表示当前页面是从哪个页面跳转过来的.

Cookie:使页面可以持久化存储一些数据,方便后续访问网站.比如存储用户当前的身份信息:登录博客后,点击博客的各种页面都会带着你登录时的信息.

Location:描述接下来要跳转的URI







构造HTTP请求的方式,实现前后端数据的交互.

1. 基于HTML/JS

   1. 基于form表单:form标签  比较原始的一种方式,使用form表单就一定会涉及 页面跳转(需要加载出全部的页面)

      ```html
      <form action = "请求访问的资源的位置(URL)" method = "请求方法(get/post)">
          !--此处的name属性相当于键值对中的key,与格式(id class)无关--,value是用户在页面上输入的值!
          <input type = "text" name = "username">
          <input type = "text" name = "password">
          !--提交就会提交到action对应的资源--!
          <input type = "submit" value = "提交">
      </form>
      ```

   2. 基于ajax:通过js代码构造出HTTP请求,再通过js代码来处理这里的响应,并把得到的数据更新到页面上.

      ajax中的第一个a表示的是"异步".区分异步和同步的是得到的结果是调用者主动调用还是由被调用者通知,异步是被动接收,同步是主动调用.同步中又分成阻塞和非阻塞,阻塞则是在等待过程中死等,不能做别的事情;非阻塞是指在等待过程中可以做别的事情,隔一段时间发一个请求看响应是否处理完成.

      基于jQuery的ajax:

      ```html
      <script src = "">
          $.ajax({
             type:"get";
             url:"..";
              !--data中存放body中的内容--!
              !--JSON.Stringify:将js对象转化为字符串格式,字符串格式按照JSON格式去构造--!
              data:JSON.Stringify({
          		!--以键值对的形式描述body--!
          	})
              success:function(body){
              
          	},
              error:function(){
                      
              }
          });
      </script>
      ```

      **浏览器禁止 ajax 进行跨域(跨越多个域名/服务器)访问,也就是说利用ajax的时候当前页面和要访问的页面必须处于一个服务器中,除非访问的服务器中允许跨域操作**

2. 基于Java

   1. 基于Socket





HTTPS中引入的加密层,称为SSL(TLS)

1. 对称加密:使用同一个密钥进行加密和解密,而要想让服务器知道客户端的密钥,需要客户端通过网络传输传递给服务器(存在被黑客入侵获取到密钥的风险).

2. 非对称加密:有两个密钥,一个公钥,一个私钥.公钥用来加密,私钥用来解密.

   非对称加密加密的是密钥,不直接对数据进行非对称加密的原因是成本太大.

   具体过程:客户端生成一个对称密钥,通过服务器的公钥进行加密,然后把加密后的密钥传输给服务器,由服务器利用私钥去进行解密得到对称密钥.至此,对称密钥只有服务器和客户端两方知道,在之后进行传输时,无须将密钥进行明文传输了.

   但仍然存在问题:在最开始客户端需要向服务器索取服务器的公钥,在这一过程中,可能会受到"中间人攻击":当服务器返回给客户端自己生成的公钥时,黑客从中间拦截到服务器的公钥,并生成一对自己的公钥和私钥,然后将自己生成的公钥发送给客户端,在之后的传输过程中,客户端发送数据进行加密的对称密钥是由黑客的密钥进行加密的,所以黑客也能够通过自己的私钥进行解密得到对称密钥,然后用从服务器得到的公钥进行加密然后传输给服务器.

   解决该问题的关键是 如何**让客户端得知拿到的公钥是由服务器生成的**,还是黑客生成的.通过**公信机构**对相应的服务器进行证书认证,然后服务器发送的公钥是放在证书里一起发送的.虽然黑客也能伪造证书,但客户端可以通过证书上的一些特征去**向公信机构进行验证.**这种验证信息中的一部分是内置在操作系统中的,避免频繁访问公信机构.(让黑客去冒充公信机构?呵呵..)

URI 和 URL

1. URI:统一资源标识符,互联网上资源的唯一标识符
2. URL:统一资源定位符,互联网上某一资源的位置.
3. URL是URI的子集.在大多数情况下,两者的含义是相同的**.URI是一种语义上的抽象概念**,定义了资源是什么;而**URL在URI的基础上还定义了如何访问某一个具体的资源,是一种真实存在的概念**.

### 简单的HTTP协议

1. HTTP的请求报文![1652865360104](C:\Users\qiu\AppData\Roaming\Typora\typora-user-images\1652865360104.png)

2. HTTP的响应报文![1652865518539](C:\Users\qiu\AppData\Roaming\Typora\typora-user-images\1652865518539.png)

3. HTTP是一种不保存的状态,即无状态协议.HTTP协议本身不会对请求和响应之间的通信状态进行保存.(不做持久化处理).确保了协议的可伸缩性,保证了通信的效率. 但是某些情景下又需要对请求和响应作保存,如实引入了cookie技术.

4. 请求URI定位资源
   1. 请求方法为GET时,请求行中的URI为完整的URI.
   2. 可以在请求头内的HOST字段中写明网络域名或IP地址
   3. 不是访问特定资源而是对服务器本身发起请求,用'*'代替URI.

5. 请求方法
   1. GET:获取资源,访问已经被URI识别的资源,经服务器端解析返回响应的内容.
   2. POST:传输实体主体.
   3. PUT:传输文件(不常用)
   4. HEAD:获得报文首部, 和GET类似,但是返回的内容中不包括响应的主体(body).
   5. DELETE:删除文件(不常用)
   6. OPTIONS:用来查询针对请求URI指定的资源支持的**方法**
   7. TRACE:让Web服务器端将之前的请求通信返回给客户端的方法.因为请求想要送达服务器端可能要经过代理中转,TRACE方法可以得到连接过程中发生的情况(不常用)
   8. CONNECT:要求在与代理服务器通信时建立隧道,实现用TCP协议进行通信.

6. 持久连接节省通信量

   在HTTP协议的初始版本中,每进行1次HTTP通信时就要断开一次TCP连接.

   持久连接:只要通信双方没有一方主动提出断开连接,TCP就一直保持连接.

   持久连接减少了TCP重复建立连接断开连接时的开销.同时也提升了通信效率.

   管线化:在管线化之前,一个请求只有在得到对应的响应时才能继续发另外一个请求.有了管线化,可以实现多个请求并行发送,提升了访问速度.

7. 使用Cookie的状态管理

   HTTP协议是一个无状态协议.正因为如此,减少了服务端的开销.但因为某些场合需要服务端去记录客户端之前的访问信息.所以引入Cookie技术

   Cookie会通过服务器端发送的响应报文中的Set-Cookie字段通知客户端在之后请求报文发送时假如Cookie字段.当服务器端解析请求报文时发现有Cookie字段时会根据该Cookie字段去得到之前该客户端的访问信息并返回给客户端响应.

   **因此,当一个请求报文中出现Cookie字段时,说明该客户端之前访问过该资源**

### HTTP报文内的HTTP信息

HTTP报文的传输形式:

1. 通过将内容压缩后再运输,提升运输效率
2. 通过分块发送,提升运输效率.
3. 发送多种数据的多部分对象集合,状态码为206的响应报文在包含了多个范围的内容时使用
4. 一次获取部分内容的请求:比如下载到一半断网,再次下载的时候从之前下载的地方开始下载.需要用到Range字段.
5. 内容协商返回最合适的内容
   1. 服务器驱动协商:服务器根据首部字段反馈一个最合适的内容
   2. 客户端驱动协商:客户端协商返回的内容,用户在浏览器的可选项列表中选出自己想要返回的内容,比如英文页面还是中文页面.
   3. 透明协商:服务器和客户端共同进行协商的一种技术

### 响应报文中的HTTP状态码

状态码:客户端向服务器发送请求后,用以描述服务器是否正常返回结果.

状态码由3位组成,其中第1位表示返回的响应类型,后两位无分类

|      | 类别             | 原因短语                   |
| ---- | ---------------- | -------------------------- |
| 1xx  | 信息性状态码     | 接收的请求正在处理         |
| 2xx  | 成功状态码       | 请求正常处理完毕           |
| 3xx  | 重定向状态码     | 需要进行附加操作已完成请求 |
| 4xx  | 客户端错误状态码 | 服务器无法处理请求         |
| 5xx  | 服务器错误状态码 | 服务器处理请求失败         |

1. 2xx:表示服务器正常返回请求

   1. 200 OK:表示服务器正常处理请求,返回的响应中的内容与请求方法有关,Get--->响应首部+响应主体,Head--->响应首部
   2. 204 No Content:表示服务器正常处理请求,但返回的响应中只有响应首部,没有响应主体.比如当浏览器中返回的响应状态码为204时,浏览器页面内容不发生更新
   3. 206 Partial Content:表示客户端进行了范围请求,而服务器针对某个范围内的资源返回给客户端.

2. 3xx:表示浏览器需要执行某些特殊的处理来完成请求

   1. 301 Moved Permanently:表示请求的资源永久性移动.以后在访问该资源时应该使用新的URI

   2. 302 Found:临时性重定向,访问的资源临时改变了URI,希望用户本次访问资源使用心的URI

   3. 303 See Other:请求的资源存在着另外一个URI,应该转用GET方法去定向获取请求的资源

      当301,302,303响应状态码返回时,大部分浏览器会自动把POST改成GET,并删除请求中的主体,然后自动重新发送请求.

   4. 304 Modified:表示客户端发送附带条件的请求时,服务器允许请求访问资源,但因为发生请求未满足条件的情况后,直接返回304 Modified.304虽然是3xx,但是和重定向没有什么关系.

3. 4xx:表明客户端时发生错误的原因所在.

   1. 400 Bad Request:发送的请求报文中出现语法错误.另外,浏览器针对该响应状态码会像对待200 OK一样,也就是说该错误不会被提示.
   2. 401 Unauthorized:发送的请求需要通过Http认证的认证信息.
   3. 403 Forbidden:没有访问该资源的权限
   4. 404 Not Found:表示在服务器上无法找到对应的资源.

4. 5xx:表明服务器本身发生错误

   1. 500 Internal Server Error:服务器在执行请求时发生了错误.
   2. 503 Service Unavailable:表明服务器暂时处于超负载或正在进行停机维护.

   **状态码与状况并不一致.不少响应返回的状态码是错误的.**

### 与HTTP协作的WEB服务器

1. 一台HTTP服务器上可以搭建多个web站点(因为虚拟服务器的存在)

2. 通信数据转发程序: 代理,网关,隧道

   1. 代理:是一种具有转发功能的**应用程序**,相当于"中间人"
      1. 代理的作用:利用**缓存技术**减少网络带宽的流量;组织内部针对特定网站的访问控制;获取访问日志.
      2. 代理的种类
         1. 缓存代理:代理在转发响应是,会预先将资源的副本缓存到自身的代理服务器上,当代理再次接收到相同的请求时,无须访问源服务器,直接从代理服务器上将资源返回给客户端.
         2. 透明代理:转发请求或响应时,不对报文作任何形式的加工.
   2. 网关:转发其他服务器通信数据的**服务器**,像源服务器一样可以对请求进行处理,还可以使通信线路上的服务器提供非HTTP协议的服务.通过在客户端和网关的线路上进行加密可以提高通信的安全性.
   3. 隧道:在相隔甚远的客户端和服务器之间进行中转,并保持通信双方建立连接的**应用程序**.可以通过SSL等加密手段提高通信安全性.

   缓存:代理服务器或客户端本地磁盘内存储的资源副本.利用缓存可以减少对源服务器的访问,减少通信时间.

   缓存是有有效期限的,不然当原服务器上的资源更新时,能够访问到的只是旧的资源.所以代理服务器会定期向源服务器发送缓存是否有效的信息,如果失效,则从源服务器上获取更新后的资源.

   客户端本地磁盘上也能够缓存一定的资源(在浏览器上叫做临时网路文件),和代理服务器中缓存的资源一样,具有有效期.




​                                                                                                                                                                                                                                                                                                                                                                                                                                                                          